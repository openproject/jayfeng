---
title: 理解设计模式(内部参考)
tags:
---

设计模式都是一套书或者一套视频的，每个设计模式精讲的话，将会是一场持久战。事实上，设计模式这个东西，理解和没理解中间有一条鸿沟，没跳过去就会反反复复，跳过去了就一下子都通了，关键是抓住它的思想和本质。

借着本文，和大家一起分享一下我对设计模式的领悟，对其中思想和本质的领悟。

## 思想和本质

每个模式都有它想强调的思想，比如工厂方法强调的用工厂封装对象的生产，单例强调的是保证唯一实例等。在初级阶段抓住思想往往是困难的，我们需要用经验来辅助理解消化并融会贯通，如果有每个模式在具体场景下的经验，设计模式不用学，对应的设计模式会非常容易理解。残酷的现实是，很多设计模式你没有机会有经验，在这样的情况下，你需要模拟并想象这个经验。

在这个过程中，务必要牢记核心也是最难的部分：这个设计模式让我们这样做是为了做出一个什么样的软件？这其实是我们软件开发时刻要思考的问题。在80-90年代，大规模软件的复杂性到了一定程度，复杂到几乎所有的大型系统都要delay，这就是传说中的第二次软件危机，所以如何设计复杂软件成了当务之急，在这个过程中，面向对象起了很重要的作用。废话不多说，直接上结论：我们应该设计出一个，可维护性好，可复用性好，可扩展性好而且灵活性好的软件。

这里特别说明一下，实现上述目标是要付出一定的代价的，大部分设计模式是用复杂化解复杂(传说中的以毒攻毒)，来达到上述目标。如果明显一个特别特别简单的软件要慎用设计模式，避免过度滥用，这种场景下只会让软件变的相对更复杂，适得其反，以毒攻不毒只会被毒死。

上面说到，面向对象在解决复杂软件问题上发挥了很重要的作用，请大家摸心四问：什么是对象？什么是封装，什么是继承，什么是多态？大家的答案各自心理清楚，我所看重不是你能不能答上来答案，而是你有没有看透这几个概念，找没找到面向对象的感觉，虽然这些概念非常重要，但是在此不赘述，以免文章拉的太长。

## 设计原则

很多人学完设计模式，大彻大悟，自我感觉良好，觉得设计模式的核心思想归根结底就是封装，继承和多态，我觉得这种说法非常的不准确，或者说太不专业，封装，继承和多态是面向对象语言的基本特性，它们只是各个模式实现的手段而已(当然手段不止于此，还有抽象，组合等)，把它们当成核心思想有点本末倒置了，那么设计模式的核心思想是什么呢？

是设计原则和这些设计原则背后的本质。
本质指的是我们应该设计出一个什么样的软件：可维护性好，可复用性好，可扩展性好而且灵活性好的软件。为了达到这个目的，世人总结了很多设计原则，有很多种分法（建议大家看看《冒号课堂》、《元素模式》），这里选择流传最广的六大原则：

> SRP：单一职责原则
> OCP：开闭原则
> LSP：里氏替换原则
> DIP：依赖倒置原则
> ISP：接口隔离眼则
> LKP：迪米特原则

简单的解释一下：
单一职责原则，只做一件事情，把这件事情做好，也不要牵连别人。强调的是对内内聚，对外解耦。
开闭原则，对扩展是开放的，对修改是关闭的，我们设计的软件应该是容易增加新功能，但是尽量不修改现有的代码，以保证系统的扩展性和可维护性。
里氏替换原则，任何基类可以出现的地方，子类一定可以出现。 这里强调的是，当子类去替换基类的时候，子类不要重写掉基类中不应该变化的东西。这是继承复用的重要基础。
依赖倒置原则，抽象不应当依赖于细节, 细节应当依赖于抽象，我们要面向接口，面向抽象，因为接口和抽象是一个比细节要稳定多的东西。
接口隔离眼则，接口的职责尽量单一，不要把很多不相关的接口放在一个接口文件里。
迪米特原则，英文名太拗口了，中文名叫最少知识原则。尽量不要和无关的类关联，知道的太多就会影响越大，我们要尽量减少这种影响。

这些原则是设计模式围绕的一个核心，每个设计模式都在解决不同的问题的同时要向这些原则看齐。因为违背这些原则实际上就很难设计出一个复杂但可控的软件，什么可维护性，可复用性，可扩展性好，灵活性将会变成一场梦，一场噩梦。

## OU结构

为了更好的应用这些设计原则，这里介绍一个技巧，ObjectUnit，面向对象单元，简称OU。

![OU结构](/images/dp_uml_objectunit.png)

OU结构是一个非常简单的结构，但是大家不要小看它。用它去理解设计模式，事半功倍，很多复杂的设计模式UML会变的简单不少。

OU结构就是基本的面向对象的一个典范，把不变的东西封装到IAbstract中，把变化的东西可以去扩展，因为是面向接口，或者说面向抽象编程，扩展新的实现非常容易。也就是说，用OU的结构提供了一个基本的“可维护性好，可复用性好，可扩展性好而且灵活性好”的技术支撑。所以当大家在设计模式中看到OU结构，第一反应应该就是一个字，好！

## 分类

讲设计模式之前，我们先分一下类。以目的来划分，分三大类，创建型，结构型和行为型。以范围分，分类模式和对象模式。
创建型模式是处理处理对象的创建；结构型模式处理类或对象的组合；行为型模式则是对类或对象怎样交互和怎样分配职责进行描述。
这些东西其实还蛮重要的，但是属于结论性的东西，这里不做过多阐述，建议大家学习的时候结合具体模式反复验证，一定会有收获的。

## 创建型模式
创建型模式是与对象的创建有关。

#### 1. 工厂方法

说工厂方法之前，我们先讲一下简单工厂。

![简单工厂UML类图](/images/dp_uml_factory_simple.png)

简单工厂，建一个工厂，根据参数返回不同的产品。简单工厂，就像它的名字一样，非常简单，解耦了Client和目标对象Target。但是这个简单的模式里面却包含了所有工厂类的一个精髓，Client和Factory又耦合了，但这个耦合与Client和Target的耦合有区别吗？这个很重要，不搞清楚这个问题，你会永远理解不了工厂类模式。答案是,区别非常大。因为这里面包含了一个变化和不变的因素，一般来说，Factory是专用于生产对象的，相对于Target的可变性要小的多，通过Factory可以把Target的变化封装起来。显然，Client依赖于一个稳定的Factory比依赖于容易变化的Target要好的多，对于系统的稳定性和灵活性更佳。

![工厂方法UML类图](/images/dp_uml_factory_method.png)

简单工厂里包含了一个if-else违背了开闭原则，会导致扩展新的产品非常难，我们把Factory转化为OU结构，同时干掉if-else，让不同的Factory子类创建不同的Product，让Client去决定调用哪个Factory，这就是工厂方法模式，这样扩展起来就更灵活了。

#### 2. 抽象工厂

![抽象工厂UML类图](/images/dp_uml_factory_abstract.png)

我们改造一下工厂模式代码，诺大的一个工厂生产一个产品太浪费了，为了最大化共享资源，让工厂可以生产相关的一系列产品，这就是抽象工厂模式，重点在于相关二字，所以抽象工厂相对于工厂方法，核心思想是封装了产品的关系，用户不用指定具体的类就能生成一系列相关产品，这个很重要，这在一些大型场景下是有必要的。

#### 3. 单例模式

![单例模式UML类图](/images/dp_uml_singleton.png)

单例模式的思想非常简单，保证只有一个实例，相对于思想，难点在于保证二字，如何从技术上实现保证。
所以如果你在面试中回答，建一个内部静态变量A，获取A的时候判断A是否为空，空就创建一个，不空就直接返回。你的回答是没错的，但是我只能给你打50分，我们要讲难点。单例模式几个基本要素，第一，静态实例变量。第二，对外全局访问点（对外公开方法）。第三，私有构造函数。第三点很重要，是为了限制外部去实例化这个对象。可以打51分了。接下来，你要区分饿汉式和懒汉式，尤其是懒汉式的延迟加载是非常有用的，可以谈一下节省资源，提高性能等等。可以给你60分。接下来继续谈线程安全。保证只有一个单例的难，难就难在这个并发上，所以我们要在全局访问点上用sychronized同步锁一下，这样就线程安全了。70分。同步锁sychronized的开销有点大，我们需要优化一下，比如双重检锁，但是双重检锁是有问题的，需要结合valotile一起使用。这个大家可以参考InfoQ上的这篇文章去深入看。80分。如果你还能再谈谈其他实现方式，比如内部静态类或者枚举，90分，如果还能再优化，99分。不给100分是防止你骄傲！

#### 4. 原型模式

![原型模式UML类图](/images/dp_uml_prototype.png)

原型模式是克隆出成千上万个几乎一模一样的实例出来（注意，几乎二字体现了我严谨的治学态度）为什么是几乎呢？因为这里面涉及到了深拷贝和浅拷贝的区别，浅拷贝只是拷贝对象一个引用(赋值)，深拷贝则是拷贝对象整个结构和数据(值类型就是复制，引用类型就是重新new一个)，原型模式原则上当然是指深拷贝，但是有时深拷贝是很难的，难到做不到。试想，一个对象里有子对象，子对象里又有子对象，子又有孙，孙又有子，子子孙孙，都去深拷贝一下不大现实，只能在某一步停下来，拷贝出一个几乎一样的对象。
原型模式往往是拷贝一个复杂的对象，它有两个优势，一是方便，方便很容易理解，一个方法就能clone出有一百个属性的对象，手动一个属性一个属性的设置的话会累死。二是性能，性能是指使用系统类一些内置的clone方法往往比你自己new性能要好，原因很简单，他比你写的好，他还做了一些优化。

其实单例模式和原型模式也属于工厂类模式，只不过创建的是自己，原型模式把自己当成原型。

#### 5. 建造者模式

![建造者模式UML类图](/images/dp_uml_builder.png)

建造者模式， 构建和表示分离，这个构建其实就是组装，建造者模式是为了解决复杂对象的组装问题。什么样的复杂对象需要组装？说的文雅一点，有多种展现形式，说的直白点，配置比较复杂。举个例子，AlertDialog，可以配置标题，自定义内容，按钮等等，还有一种比较常见的，就是一些第三方库的一些config，也是配置一大堆参数，这样的对象配置繁琐，为了简化配置的学习，我们把配置的行为单独拎出来，不和整个对象混合在一起，这就是建造者模式要做的事情的核心思想，分离职责，分离组装的职责。基于此，带来了两个直接好处，第一，降低了组装的学习成本。第二，巧用流式接口。在原复杂对象上的一些方法上使用流式接口会显得比较混乱，而在Builder上使用流式接口则是非常自然的，因为它几乎是全配置的。

理解了上述，后面就不难了，我们可以内置若干Builder，为Builder封装一个指导者，还可以更复杂的，OU一下Builder，到了这个程度建造者模式的理解就差不多了。

到这里，创建型模式就完了，总结一下，创建型模式，重点都是在封装，封装对象的创建，降低和目标对象的直接耦合。

## 结构型模式
结构型模式处理类或对象的组合。

结构型模式不再关注对象的创建了，重点处理类或者对象的组合。所以，在介绍模式之前，我们顺便点评一下组合和继承，为什么网上流行说，组合优于继承。这句话我不知道是谁改的，GOF书上的原话是，优先使用对象组合，而不是类继承。因为类继承关系是垂直方向的结构重用，是IS-A关系，是一种强耦合的复用机制。对象组合则是水平方向的功能借用，是HAS-A关系，是一种比类继承弱的多的复用机制。

#### 6. 适配器模式

![类适配器UML类图](/images/dp_uml_adapter_all.png)

适配器模式，将一个类的接口(Adpatee)转换成客户希望的另外一个接口(Adapter)。怎么转？两种方法，Adapter继承Adaptee，然后增加新的接口，在新的接口中调用老的接口。第二种方法，Adapter组合Adaptee，然后增加新的接口，在新的接口中调用Adaptee的接口。我们推荐使用第二种方法，更加轻量级，更加符合设计原则。大家在Android开发中使用的listview适配器使用的是对象适配器，但述模型要稍微复杂一点，它把adapter抽象了一下，使用的是一个OU化的Adapter，有很多Adapter去适配各种集合类型。

#### 7. 代理模式

![代理模式UML类图](/images/dp_uml_proxy.png)

和对象适配器模式非常相似的是代理模式，这里就是说，代理和适配一个对象的区别是什么？代理模式强调的是控制一个对象的访问，所以大家不要Focus在增加新接口上。不但如此，我们希望这种代理是弱感知的，所以代理对象Proxy最好和被代理对象是统一的，那就让它们实现同一个接口吧。那么代理模式强调控制这个对象的访问有什么好处呢？好处就是，据此你可以加一些东西，比如权限，比如日志等等。

大家可以看的出来，代理模式中代理一个对象还要实现其上层的接口，每次写这样的代理类非常的麻烦。Java中有个比较有名的动态代理，大大简化代码提高代码的灵活性，有兴趣可以去看看。

#### 8. 外观模式

![外观模式UML类图](/images/dp_uml_facade.png)

如果说代理模式代理的是一个对象的访问，外观模式代理的则是一个系统的访问，就会组合很多个对象了。所以这里强调更多的是一种架构的思想，是一种大颗粒的设计模式，基于这种思想，我们就很容易写出Glide.with()和picasso这样的优雅的门面代码了，考虑颗粒的不同，对设计模式是有影响的，大家可以思考一下，这里不展开讨论了。

#### 9. 桥接模式

![桥接模式UML类图](/images/dp_uml_bridge.png)

桥接模式听名字和适配器模式好像很相似，实际上并非如此，桥接模式桥接的是什么？我们看意图。"抽象和实现，让它们都能够独立的变化"，桥接的是抽象和实现，大家先不必太刻意追求这两个词的真正含义(桥接模式是说起来很复杂，其实是很容易理解的一个模式)，说白了，它们是指如何从两个不同的纬度扩展变化。还是很抽象，用实例说明，鸟，通过继承，我们可以派生出小鸟，老鹰等。这样通过继承实现了一个纬度的变化，这是大家天天写的代码。各个鸟的食物是不一样的，在鸟这个基类里组合一个食物的抽象类，小鸟的食物是虫子，老鹰的食物是老鼠，这样通过组合实现了另外一个纬度的变化。桥接模式就是这样实现两个纬度的独立变化。现实中这样的代码其实非常多，大家天天用的ListView的父类AbsListView就是一个经典的例子，可以派生出ListView和GridView，同时可以组合Adapter。

桥接模式就是一个OU结构组合了另外一个OU结构，弄懂了这个二维的扩展，三维，四维等多维的扩展也不在话下，但是三维思维等就只能用组合了，这也是组合比继承扩展更灵活的一个表现。

#### 10. 组合模式

![组合模式UML类图](/images/dp_uml_composite.png)

组合模式是“将对象组合成树形结构以表示‘部分-整体’的层次结构”，重点在于处理Tree结构中的枝节点和叶子节点的差异性。如何让有差异性的东西变得几乎没有差异性？答案是抽象，把枝节点和叶子节点抽象出共用部分，就是一个OU结构。叶子节点只是枝节点的一部分，所以说枝节点是完全包含叶子节点，这个地方使用继承是非常正确的。枝节点有自己的管理叶子节点的几个方法。所以，组合模式强调的是屏蔽TREE结构中枝节点和叶子节点的差异性，这个在Android中的View和ViewGroup，File和Dirctory，XML解析都是有直接体现的，是非常有用的。

组合模式是""干掉""了树型结构中不同类型节点的差异性，后面的访问者模式，则是干掉了迭代列表中不同类型的方法调用的差异性，后面我们再讲。

#### 11. 享元模式

![享元模式UML类图](/images/dp_uml_flyweight.png)

享元模式使用了一个工厂类来管理一个单例池，来实现对象的重用，这个单例池是共享的，这对于一些种类少数量多的那些对象是非常有必要的，能极大的节约内存。

享元模式还有一个很重要的核心，就是内外部状态的区分，一定要注意外部状态的赋值。

#### 12. 装饰者模式

![装饰者模式UML类图](/images/dp_uml_decorator.png)

装饰者模式，有个别名叫wrapper，装饰二字的意思就是指，包装新职责。为一个对象添加新职责最简单的方式就是继承这个对象，增加新的接口即可。当职责比较多比如A、B、C而且有的时候只需要AB或者BC之类的时候，就需要选组合这些职责，这个时候通过继承生成子类的这个方式就比较笨重了，会生成大量的子类（不考虑顺序共有A、B、C、AB、AC、BC、ABC7种）。如果能用对象的组合，则可根据需要组合A、B、C3种即可。

装饰者说明了这些装饰者的实现方式，比如原始类是Component，装饰类：DecoratorA, DecoratorB, DecoratorC。第一，为了让原始类和装饰类使用起来几乎是统一的，提取出公用的接口；第二，把这个统一的接口组合到装饰类中，后面根据需要注入原始类或者装饰类；第三，在这个装饰类中增加新职责。

结构型模式就到这里，强调一下，大家着重理解组合二字在其中的广泛应用。

## 行为型模式
行为型模式强调的是对类或对象怎样交互和怎样分配职责，对象的交互和分离职责一直是我们应该关心的问题。

#### 13. 模板方法模式

![模板方法模式UML类图](/images/dp_uml_template_method.png)

模板方法模式。当大家打开新建一个Activity的时候，我们总是会去写onCreate，onResume，onDestory方法，为什么呢？因为我们知道这些方法是固定的，它们的执行顺序也是固定的，它们是Activity的生命周期，这个生命周期是几乎永远不变的，Android系统把它提取出来，开发者只需要实现具体的每个步骤，大大简化了Activity的使用。像这样的生命周期就是不变的骨架，把不变的东西提取出来，把自定义的东西交给子类去延后覆写，这就是模板方法模式。

模板方法设计图东西比较少，因为它确实也就使用了一下基本的继承，封装了一下骨架。

#### 14. 观察者模式
![观察者模式UML类图](/images/dp_uml_observer.png)

观察者模式。很多面试者说懂观察者模式，说Android的按钮点击就是观察者模式，然后没下文了，说怎么做到的也不知道，这是我比较反感的，其实就是不懂。观察者模式其实是一种非常有思想有意义的模式，思想在于，它把高代价的观察变化转化成了低成本的通知变化，把一个很难的观察按钮变化分问题转化成了一个很容易的按钮被点击后发出通知的问题，意义在于，它改变了我们编程思维，尤其在现在这个多核并发的时代。大家可以去了解一下事件驱动编程。

看设计图，Subject就是按钮，Observer就是按钮点击后要执行代码的对象，观察者模式简化的说，就是注册，然后被通知。

#### 15. 解释器模式

![解释器模式UML类图](/images/dp_uml_interpreter.png)

解释器模式，是一个很具体的模式，就是要去写解释器，但是是用面向对象的方式写解释器，这样就能更方面的做出一个可维护性好，可复用性好，可扩展性好而且灵活性好的解释器。怎么做呢？结合上面的这个计算公式我们看UML图，第一，所有的元素（包括常量，变量和操作符）都要转化成表达式对象。我们抽象一下表达式对象AbstractExpression。第二，常量和变量属于终结符表达式，操作符输入非终结表达式，AbstractExpression分为这两类。其中非终结表达式是可以连接终结表达式，所以非终结表达式需要传入两个终结表达式。最终可以得到终的表达式。
解释器模式其实使用的还是比较多的，我写过一个打印的模板解析，就是解析一个表达式。现在比较流行DSL，如果你想自己定制一个，也可以考虑使用解释器模式。

#### 16. 迭代器模式

![迭代器模式UML类图](/images/dp_uml_iterator.png)

迭代器模式，提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。这里面有两个点，第一，要去实现迭代器接口迭代聚合对象；第二，封装性，我们为什么要去实现迭代聚合对象？外部也可以实现的，就是为了隐藏内部表示，同时也方便了外部调用。考虑到一些自定义的聚合对象的遍历对外部来讲是很陌生，所以迭代器模式是非常有必要的。另外，Java中的集合都实现了迭代器接口，内置了迭代器模式，甚至增强了一下，支持更方便的foreach。
迭代器模式的意义在于它抽象了集合的遍历行为，进而统一了所有集合对象的迭代行为，对开发者或者说对外部调用者是很有意义的。

#### 17. 命令模式

![命令模式UML类图](/images/dp_uml_command.png)

命令模式做了什么，将一个请求封装为一个对象。OK，看到这里就可以了，后面暂时不用看。这个请求说白了就是对象间的调用。为什么要把一个请求封装成对象呢？大家看下面的图，本来invoker直接调用receiver的，现在加了一层command，这个command是一个典型的OU结构，扩展性强，灵活性好，OK，发生了什么，invoker和receiver解耦了。而且中间的命令既可以扩展不同的命令也可以对请求进行一定的二次处理，像意图中的请求参数化，对请求排队，记录日志都不在话下。这是命令模式的本身意义，把请求这个东西抽象化了。

除此之外，我想强调一下命令模式的另外一点，它本质上是一个代码块，包含未知算法的一个代码块，大家回想一下Thread，这些方法都是没有返回值的，可以说就是一个单接口的无返回值的OU结构。这种结构太基础了，所以命令模式是一个很基础的设计模式。

#### 18. 策略模式

![策略模式UML类图](/images/dp_uml_strategy.png)

如果把无返回值改为返回值，就变成了策略模式。因为策略模式特别强调这个返回值，而忽略其他，所以策略模式特别简单。可以说就是一个OU结构，策略模式把这种封装的有返回值的代码块称作算法，说简单点就是实现。基于OU结构的强大，这些算法想怎么换就怎么换。这其实是解耦了具体的算法实现，在一些算法需要灵活变化的场景下非常有用。

命令模式和策略模式都非常简单，简单不代表不重要，他们重要性体现在它们规范了(或者说指导了)面向对象系统在代码块这个颗粒级别的思考方式(代码块的对象化)，这个很重要，大家可以考虑一下lambda表达式，这里不展开了。

#### 19. 职责链模式

![职责链模式UML类图](/images/dp_uml_chainofresponsibility.png)

职责链模式和状态模式，分别封装的是行为和状态的自我处理。

职责链模式把具备不同处理能力的一系列处理者连成一根链条，发送者不用和每个处理者的逻辑耦合，只需要把处理的请求交给链条的开端即可，处理者会依次传递请求直到被处理为止。所以重点在于，我们如何把它们连起来？第一，我们要抽象节点，提取公用的处理方法handleRequest；第二，每个节点组合一个后继节点，因为每个都有这个后继点，完全可以提取到抽象节点中，然后交给客户注入具体的后继对象，所以这里的Handler用抽象类而不是接口。
职责链模式，就做一件事情，行为的传递。这在Android中也有一些例子，View的事件传递，retrofit的网络拦截都是这样的模型。

#### 20. 状态模式

![状态模式UML类图](/images/dp_uml_state.png)

状态模式。和职责链模式不同的是，状态模式强调的是状态的触发，状态能自动转换，并触发不同的行为。
状态模式一般用于多个状态不同行为的场景，比如tcp通信，下载管理器等。
我们看看意图：“允许一个对象在其内部状态改变时改变它的行为”。什么意思？我们看一个开关的例子，如果开则关，如果关则开，这是一个典型的if-else结构，能不能改进一下，让这些状态自己去管理自己的状态？是可以的。我们把这些对象抽象出来IState，把各个State的行为分离在各个State本身里面，而且每个State变化之后自动更新Context的状态，这样扩展新的状态也将会变的更容易。我们看看最终的代码。每次我们去request的时候，就能实现“对象状态的自动化”，行为也被分离了，变的更清晰了。

#### 21. 中介者模式

![中介者模式UML类图](/images/dp_uml_mediator.png)

中介者模式，“用一个中介对象来封装一系列的对象交互”。显然，新增加一层"中介者”解耦这些对象的交互，这是好处，坏处是引入了一个中介者。所以中介者是用一个对象的复杂度换取一组对象的简化，这在很多场景下是值得的。中介者模式的实现逻辑其实和观察者模式类似，创建一个中介者，交互对象把自己注册进去，在需要的时候通知中介者交互。
MVP中的Presenter就是一个简化版本的中介者。
关于中介者模式，我提几个注意的点。第一，不要让中介者变成一个god类，让它只专注于中介就好了。第二，中介者模式和观察者模式在实现上是非常相似的，只不过观察者是一对一的注册，由被观察者发出通知。而中介者模式是多对一对多的关系，由交互对象自己发送通知。第三，经典的中介者模式把蜘蛛网结构变成了一个星状结构，可以看的出来，和外观模式是一个偏架构思想的模式，适合解决复杂问题。

#### 22. 备忘录模式

![备忘录模式UML类图](/images/dp_uml_memento.png)

备忘录模式也叫快照模式或者存档模式，意思很明显了。实现快照或者存档这样的功能其实不难，但有个注意的地方，不会破坏封装性。比如说有个A对象，有一些状态要存档一下，你不能暴露你的这些内部状态属性，那怎么办呢？所以只能把这些属性封装在一个Memento类里，A自己实现createMemento()方法。对外的客户甚至不知道这个Memento的存在。
所以备忘录模式解决的问题是什么，是如何保密的存档。
这里有一个外部化类，是做持久化和恢复的，问大家一个问题，为什么要搞这么一个外部化类？是为了分离职责哈，持久化的操作不应该放在本身对象中，交给专门的人去做会更好。

#### 23. 访问者模式

![访问者模式UML类图](/images/dp_uml_visitor.png)

最后一个模式，访问者模式。很多人被这个模式坑了很多年，一直搞不懂这个号称最难的一个设计模式。其实这个模式本身压根不难，只不过场景比较少，而且被很多人很多书讲复杂了。首先我们得想对场景，访问者模式是干嘛的？是遍历一个特殊集合，去调用每个元素的不同的方法。

按照常理，我们会写出这样的代码，大家觉得这样的代码好吗？
```java
for (IElement element : elements) {
    if (element instanceof ElementA) {
        ((ElementA) element).a();
    } else if (element instanceof  ElementB) {
        ((ElementB) element).b();
    }
}
```

这个代码太丑陋了，有两点，第一，if-else结构；第二，强制转换。
访问者模式提出，我们可以增加一个访问者，访问者去控制调用哪个方法。同时，每个元素支持注入这个访问者。
```Java
public interface IElement {
    void accept(Visitor visitor);
}
public class ElementA implements IElement{

    public void a() {
        System.out.println("AAAAAAAA");
    }

    @Override
        public void accept(Visitor visitor) {
            visitor.visitElementA(this);
        }
}
public class ElementB implements IElement {

    public void b() {
        System.out.println("BBBBBBBBB");
    }

    @Override
        public void accept(Visitor visitor) {
            visitor.visitElementB(this);
        }
}
```
我们来看结果，是如此的优雅:
```Java
// 如此的优雅!
for (IElement element : elements) {
     element.accept(new Visitor());
}
```
除此之外，我们可以把这个Visitor转化为OU结构，变的更强大了，这就是经典的访问者模型，我们回头去看访问者的意图和UML图：“表示一个作用于某对象结构中的各元素的操作”，这句话说的就是这个Visitor。“它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作”，当我们选择不同的Visitor实现是不是就可以实现切换到新操作这个功能。

这就是访问者模式，顺便提一下，大家不要被双分派的语言特性绕进去了，用一个大家不熟悉的东西去解释另外一个不熟悉的东西，只会更加困扰！

## 回顾

回顾一下设计模式三大分类的侧重点：
> 创建型模式，new
> 结构型模式，组合，继承
> 行为型模式，对象交互，分配职责

虽然把经典23种设计模式从头到尾分析了一遍，但是可能很多人依然不懂的还是不懂，多去揣摩它们的核心思想，抓住背后的本质，思考我们应该做出什么样的软件才是正解，理解设计模式，每个人都可以做到。

## 几条小技巧

最后送大家几条“锦囊妙计”：
> 考虑用OU结构替换if-else结构
> 从意图的角度去理解设计模式，会事半功倍
> 有些设计模式是不同颗粒的相似形态
> 建立对象化思维，一切皆为对象
> 转移耦合到更稳定的间接层

（全文完）
